// --- æ ¸å¿ƒå˜é‡éƒ¨åˆ† ---
    let peer, connections = [], myName = "";
    let isHost = false;
    const urlParams = new URLSearchParams(window.location.search);
    const roomID = urlParams.get('room');
    let customRoomName = urlParams.get('roomName') || "ä¸´æ—¶èŠå¤©å®¤";

    // è‡ªåŠ¨è¯»å–ä¸Šæ¬¡çš„æ˜µç§°
    document.getElementById('user-name').value = localStorage.getItem('p2p-nickname') || "";

    function startApp() {
        myName = document.getElementById('user-name').value.trim() || "åŒ¿åè€…";
        localStorage.setItem('p2p-nickname', myName); // è®°ä½æ˜µç§°

        if (!roomID) {
            const inputName = prompt("ç»™ä½ çš„èŠå¤©å®¤èµ·ä¸ªåå­—å§ï¼š", customRoomName);
            if (inputName) customRoomName = inputName;
        }
        document.getElementById('setup-layer').style.display = 'none';
        initPeer();
    }

    function initPeer() {
        // å¦‚æžœæ˜¯æˆ¿ä¸»ï¼Œæˆ‘ä»¬å°è¯•åˆ›å»ºä¸€ä¸ªç›¸å¯¹å›ºå®šçš„ ID é˜²æ­¢åˆ·æ–°å°±æ­»
        // æ³¨æ„ï¼šPeerJS å®˜æ–¹æœåŠ¡å™¨å¦‚æžœ ID è¢«å ç”¨ä¼šæŠ¥é”™ï¼Œè¿™é‡Œç®€å•å¤„ç†
        peer = new Peer(); 

        peer.on('open', (id) => {
            if (!roomID) {
                isHost = true;
                const inviteUrl = `${window.location.origin}${window.location.pathname}?room=${id}&roomName=${encodeURIComponent(customRoomName)}`;
                document.getElementById('room-name-display').innerText = `ðŸ  ${customRoomName} (1äºº)`;
                document.getElementById('share-url').innerText = "ç‚¹å‡»å¤åˆ¶é‚€è¯·é“¾æŽ¥";
                document.getElementById('share-url').onclick = () => {
                    navigator.clipboard.writeText(inviteUrl);
                    alert("é“¾æŽ¥å·²å¤åˆ¶ï¼");
                };
            } else {
                connectToHost(roomID);
            }
        });

        peer.on('connection', (conn) => {
            handleConnection(conn);
        });
    }

    function connectToHost(id) {
        isHost = false;
        const conn = peer.connect(id, { metadata: { name: myName } });
        handleConnection(conn);
    }

    function handleConnection(conn) {
        conn.on('open', () => {
            if (!connections.find(c => c.peer === conn.peer)) {
                connections.push(conn);
            }
            
            // æˆ¿ä¸»é€»è¾‘ï¼šæ¯å½“æœ‰äººæ¥ï¼Œè®¡ç®—æ€»äººæ•°å¹¶å¹¿æ’­
            if (isHost) {
                const totalCount = connections.length + 1;
                updateUserCount(totalCount);
                broadcast({ type: 'COUNT_UPDATE', count: totalCount });
            }
            
            appendLog('sys', `${conn.metadata.name || "æ–°æœ‹å‹"} è¿›å…¥äº†æˆ¿é—´`);

            conn.on('data', (data) => {
                // å¦‚æžœæ”¶åˆ°çš„æ˜¯äººæ•°æ›´æ–°æŒ‡ä»¤
                if (data.type === 'COUNT_UPDATE') {
                    updateUserCount(data.count);
                    return;
                }
                // æ­£å¸¸çš„èŠå¤©æ¶ˆæ¯è½¬å‘
                if (isHost) broadcast({ name: data.name, text: data.text }, conn);
                appendLog('peer', data.text, data.name);
            });
        });

        conn.on('close', () => {
            connections = connections.filter(c => c !== conn);
            if (isHost) {
                const totalCount = connections.length + 1;
                updateUserCount(totalCount);
                broadcast({ type: 'COUNT_UPDATE', count: totalCount });
            }
        });
    }

    function updateUserCount(count) {
        const title = isHost ? `ðŸ  ${customRoomName}` : `ðŸ’¬ ${customRoomName}`;
        document.getElementById('room-name-display').innerText = `${title} (${count}äºº)`;
    }

    function broadcast(data, excludeConn) {
        connections.forEach(c => {
            if (c !== excludeConn && c.open) c.send(data);
        });
    }

    function sendMsg() {
        const input = document.getElementById('msg-input');
        const text = input.value.trim();
        if (!text) return;
        const data = { name: myName, text: text };
        connections.forEach(c => { if(c.open) c.send(data); });
        appendLog('me', text, myName);
        input.value = '';
    }
